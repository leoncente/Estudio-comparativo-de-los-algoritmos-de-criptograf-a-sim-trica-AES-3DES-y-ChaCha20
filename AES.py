import numpy as np

#Tabla s-Box
s_box = [0x63,0x7C,0x77,0x7B,0xF2,0x6B,0x6F,0xC5,0x30,0x01,0x67,0x2B,0xFE,0xD7,0xAB,0x76,
0xCA,0x82,0xC9,0x7D,0xFA,0x59,0x47,0xF0,0xAD,0xD4,0xA2,0xAF,0x9C,0xA4,0x72,0xC0,
0xB7,0xFD,0x93,0x26,0x36,0x3F,0xF7,0xCC,0x34,0xA5,0xE5,0xF1,0x71,0xD8,0x31,0x15,
0x04,0xC7,0x23,0xC3,0x18,0x96,0x05,0x9A,0x07,0x12,0x80,0xE2,0xEB,0x27,0xB2,0x75,
0x09,0x83,0x2C,0x1A,0x1B,0x6E,0x5A,0xA0,0x52,0x3B,0xD6,0xB3,0x29,0xE3,0x2F,0x84,
0x53,0xD1,0x00,0xED,0x20,0xFC,0xB1,0x5B,0x6A,0xCB,0xBE,0x39,0x4A,0x4C,0x58,0xCF,
0xD0,0xEF,0xAA,0xFB,0x43,0x4D,0x33,0x85,0x45,0xF9,0x02,0x7F,0x50,0x3C,0x9F,0xA8,
0x51,0xA3,0x40,0x8F,0x92,0x9D,0x38,0xF5,0xBC,0xB6,0xDA,0x21,0x10,0xFF,0xF3,0xD2,
0xCD,0x0C,0x13,0xEC,0x5F,0x97,0x44,0x17,0xC4,0xA7,0x7E,0x3D,0x64,0x5D,0x19,0x73,
0x60,0x81,0x4F,0xDC,0x22,0x2A,0x90,0x88,0x46,0xEE,0xB8,0x14,0xDE,0x5E,0x0B,0xDB,
0xE0,0x32,0x3A,0x0A,0x49,0x06,0x24,0x5C,0xC2,0xD3,0xAC,0x62,0x91,0x95,0xE4,0x79,
0xE7,0xC8,0x37,0x6D,0x8D,0xD5,0x4E,0xA9,0x6C,0x56,0xF4,0xEA,0x65,0x7A,0xAE,0x08,
0xBA,0x78,0x25,0x2E,0x1C,0xA6,0xB4,0xC6,0xE8,0xDD,0x74,0x1F,0x4B,0xBD,0x8B,0x8A,
0x70,0x3E,0xB5,0x66,0x48,0x03,0xF6,0x0E,0x61,0x35,0x57,0xB9,0x86,0xC1,0x1D,0x9E,
0xE1,0xF8,0x98,0x11,0x69,0xD9,0x8E,0x94,0x9B,0x1E,0x87,0xE9,0xCE,0x55,0x28,0xDF,
0x8C,0xA1,0x89,0x0D,0xBF,0xE6,0x42,0x68,0x41,0x99,0x2D,0x0F,0xB0,0x54,0xBB,0x16]

#Tabla s-Box inversa
inv_s_box = [0x52,0x09,0x6A,0xD5,0x30,0x36,0xA5,0x38,0xBF,0x40,0xA3,0x9E,0x81,0xF3,0xD7,0xFB,
0x7C,0xE3,0x39,0x82,0x9B,0x2F,0xFF,0x87,0x34,0x8E,0x43,0x44,0xC4,0xDE,0xE9,0xCB,
0x54,0x7B,0x94,0x32,0xA6,0xC2,0x23,0x3D,0xEE,0x4C,0x95,0x0B,0x42,0xFA,0xC3,0x4E,
0x08,0x2E,0xA1,0x66,0x28,0xD9,0x24,0xB2,0x76,0x5B,0xA2,0x49,0x6D,0x8B,0xD1,0x25,
0x72,0xF8,0xF6,0x64,0x86,0x68,0x98,0x16,0xD4,0xA4,0x5C,0xCC,0x5D,0x65,0xB6,0x92,
0x6C,0x70,0x48,0x50,0xFD,0xED,0xB9,0xDA,0x5E,0x15,0x46,0x57,0xA7,0x8D,0x9D,0x84,
0x90,0xD8,0xAB,0x00,0x8C,0xBC,0xD3,0x0A,0xF7,0xE4,0x58,0x05,0xB8,0xB3,0x45,0x06,
0xD0,0x2C,0x1E,0x8F,0xCA,0x3F,0x0F,0x02,0xC1,0xAF,0xBD,0x03,0x01,0x13,0x8A,0x6B,
0x3A,0x91,0x11,0x41,0x4F,0x67,0xDC,0xEA,0x97,0xF2,0xCF,0xCE,0xF0,0xB4,0xE6,0x73,
0x96,0xAC,0x74,0x22,0xE7,0xAD,0x35,0x85,0xE2,0xF9,0x37,0xE8,0x1C,0x75,0xDF,0x6E,
0x47,0xF1,0x1A,0x71,0x1D,0x29,0xC5,0x89,0x6F,0xB7,0x62,0x0E,0xAA,0x18,0xBE,0x1B,
0xFC,0x56,0x3E,0x4B,0xC6,0xD2,0x79,0x20,0x9A,0xDB,0xC0,0xFE,0x78,0xCD,0x5A,0xF4,
0x1F,0xDD,0xA8,0x33,0x88,0x07,0xC7,0x31,0xB1,0x12,0x10,0x59,0x27,0x80,0xEC,0x5F,
0x60,0x51,0x7F,0xA9,0x19,0xB5,0x4A,0x0D,0x2D,0xE5,0x7A,0x9F,0x93,0xC9,0x9C,0xEF,
0xA0,0xE0,0x3B,0x4D,0xAE,0x2A,0xF5,0xB0,0xC8,0xEB,0xBB,0x3C,0x83,0x53,0x99,0x61,
0x17,0x2B,0x04,0x7E,0xBA,0x77,0xD6,0x26,0xE1,0x69,0x14,0x63,0x55,0x21,0x0C,0x7D]

#Tabla para simplificar el calculo de la variable Rcon
r_con = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40,
       0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A,
       0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A,
       0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39]

class AES:
  #Funcion principal de encriptacion
  def encrypt(self,txt, key):
    tam = np.prod(txt.shape)
    if tam % 16 != 0:
      for x in range(16 - (tam % 16)):
        txt = np.append(txt, 0x00)

    blocks = np.prod(txt.shape)//16

    nk = np.prod(key.shape)//4

    nr = 10
    if nk == 6:
      nr = 12
    elif nk == 8:
      nr = 14

    key = self.keyExpansion(key, nk)

    res = np.empty(blocks*16,dtype=np.uint8)
    for x in range(blocks):
      res[(x*16):((x*16)+16)] = self.encryptBlock(txt[(x*16):((x*16)+16)], key, nr)

    return res

  #Funcion principal de desencriptacion
  def decrypt(self, txt, key):
    blocks = np.prod(txt.shape)//16

    nk = np.prod(key.shape)//4

    nr = 10
    if nk == 6:
      nr = 12
    elif nk == 8:
      nr = 14

    key = self.keyExpansion(key, nk)
    res = np.empty(blocks*16,dtype=np.uint8)
    for x in range(blocks):
      res[(x*16):((x*16)+16)] = self.decryptBlock(txt[(x*16):((x*16)+16)], key, nr)

    t = np.prod(res.shape)
    c = 0
    f = True
    aux1 = t - 1
    while f:
      if(res[aux1] == 0):
        c += 1
      else:
        f = False
      aux1 -= 1
    return res[0:t - c]

  #Funcion que encripta un bloque de 16 bytes
  def encryptBlock(self, state, key, nr):

    state = self.AddRoundKey(state, key[0:16])

    for r in range(1,nr):
      state = self.SubBytes(state)
      state = self.ShiftRows(state)
      state = self.MixColumns(state)
      state = self.AddRoundKey(state, key[(r*16):((r*16)+16)])

    state = self.SubBytes(state)
    state = self.ShiftRows(state)
    state = self.AddRoundKey(state, key[(nr*16):((nr*16)+16)])

    return state

  #Funcion SubBytes
  def SubBytes(self, state):
    res = []
    for x in np.nditer(state):
      res.append(self.funSBox(x))
    return np.asarray(res)

  #Funcion ShiftRows
  def ShiftRows(self, s):
    res = np.array([s[0],s[5],s[10],s[15],s[4],s[9],s[14],s[3],s[8],s[13],s[2],s[7],s[12],s[1],s[6],s[11]], dtype=np.uint8)
    return res

  #Funcion MixColumns
  def MixColumns(self, state):
    res = []
    res.extend(self.mixColumn(state[0],state[1],state[2],state[3]))
    res.extend(self.mixColumn(state[4],state[5],state[6],state[7]))
    res.extend(self.mixColumn(state[8],state[9],state[10],state[11]))
    res.extend(self.mixColumn(state[12],state[13],state[14],state[15]))
    return np.asarray(res)

  #Funcion MixColumn para una sola columna
  def mixColumn(self, b0, b1, b2, b3):
    r0 = b2 ^ b3 ^ b1 ^ self.xtime(b0 ^ b1)
    r1 = b0 ^ b3 ^ b2 ^ self.xtime(b1 ^ b2)
    r2 = b0 ^ b1 ^ b3 ^ self.xtime(b2 ^ b3)
    r3 = b1 ^ b2 ^ b0 ^ self.xtime(b0 ^ b3)
    return [r0, r1, r2, r3]

  #Funcion xtime
  def xtime(self, byte):
    if byte & 0x80:
      byte = ((byte << 1) ^ 0x1b) & 0xff
    else:
      byte = byte << 1
    return byte

  def AddRoundKey(self, block1, block2):
    add = np.vectorize(XORAES)
    return add(block1, block2)

  #Funcion que desencripta un bloque de 16 bytes
  def decryptBlock(self, state, key, nr):

    state = self.AddRoundKey(state, key[(nr*16):((nr*16)+16)])

    for r in range(nr-1, 0, -1):
      state = self.InvShiftRows(state)
      state = self.InvSubBytes(state)
      state = self.AddRoundKey(state, key[(r*16):((r*16)+16)])
      state = self.InvMixColumns(state)

    state = self.InvShiftRows(state)
    state = self.InvSubBytes(state)
    state = self.AddRoundKey(state, key[0:16])

    return state

  #Funcion InvSubBytes
  def InvSubBytes(self, state):
    res = []
    for x in np.nditer(state):
      res.append(self.funInvSBox(x))
    return np.asarray(res)

  #Funcion InvShiftRows
  def InvShiftRows(self, s):
    return np.array([s[0],s[13],s[10],s[7],s[4],s[1],s[14],s[11],s[8],s[5],s[2],s[15],s[12],s[9],s[6],s[3]], dtype=np.uint8)

  #Funcion InvMixColumns
  def InvMixColumns(self, state):
    res = []
    res.extend(self.invMixColumn(state[0],state[1],state[2],state[3]))
    res.extend(self.invMixColumn(state[4],state[5],state[6],state[7]))
    res.extend(self.invMixColumn(state[8],state[9],state[10],state[11]))
    res.extend(self.invMixColumn(state[12],state[13],state[14],state[15]))
    return np.asarray(res)

  #Funcion MixColumn para una sola columna
  def invMixColumn(self, b0, b1, b2, b3):
    xb0 = self.xtime(b0)
    xxb0 = self.xtime(xb0)
    xxxb0 = self.xtime(xxb0)
    xb1 = self.xtime(b1)
    xxb1 = self.xtime(xb1)
    xxxb1 = self.xtime(xxb1)
    xb2 = self.xtime(b2)
    xxb2 = self.xtime(xb2)
    xxxb2 = self.xtime(xxb2)
    xb3 = self.xtime(b3)
    xxb3 = self.xtime(xb3)
    xxxb3 = self.xtime(xxb3)
    r0 = (xb0^xxb0^xxxb0) ^ (b1^xb1^xxxb1) ^ (b2^xxb2^xxxb2) ^ (b3^xxxb3)
    r1 = (b0^xxxb0) ^ (xb1^xxb1^xxxb1) ^ (b2^xb2^xxxb2) ^ (b3^xxb3^xxxb3)
    r2 = (b0^xxb0^xxxb0) ^ (b1^xxxb1) ^ (xb2^xxb2^xxxb2) ^ (b3^xb3^xxxb3)
    r3 = (b0^xb0^xxxb0) ^ (b1^xxb1^xxxb1) ^ (b2^xxxb2) ^ (xb3^xxb3^xxxb3)
    return [r0, r1, r2, r3]

  #Funsion de expansion de llave
  def keyExpansion(self, key, nk):
    nr = 10
    if nk == 6:
      nr = 12
    elif nk == 8:
      nr = 14

    i = nk

    add = np.vectorize(XORAES)
    while i < (4 * (nr + 1)):
      temp = np.array([key[(i-1)*4], key[(i-1)*4 + 1], key[(i-1)*4 + 2], key[(i-1)*4 + 3]],dtype=np.uint8)
      if i % nk == 0:
        temp = add(self.SubWord(self.RotWord(temp)),self.Rcon(i//nk))
      elif nk > 6 and i % nk ==4:
        temp = self.SubWord(temp)

      temp = add(temp, np.array([key[(i-nk)*4], key[(i-nk)*4 + 1], key[(i-nk)*4 + 2], key[(i-nk)*4 + 3]],dtype=np.uint8))
      key = np.append(key,temp)
      i += 1

    return key

  #Funcion SubWord
  def SubWord(self, word):
    res = np.empty(4, dtype=np.uint8)
    aux = 0
    for x in np.nditer(word):
      res[aux] = self.funSBox(x)
      aux += 1
    return res

  #Funcion para mapear a la tabla S-Box
  def funSBox(self, byte):
    row = byte >> 4
    col = byte % 16
    return s_box[(row*16)+col]

  #Funcion para mapear a la tabla S-Box inversa
  def funInvSBox(self, byte):
    row = byte >> 4
    col = byte % 16
    return inv_s_box[(row*16)+col]

  #Funcion RotWord
  def RotWord(self, word):
    return np.roll(word, -1)

  #Constante Rcon
  def Rcon(self, num):
    return np.array([r_con[num],0x00,0x00,0x00], dtype=np.uint8)

#Funcion que aplica XOR entre dos bytes
def XORAES(byte1, byte2):
  return byte1 ^ byte2